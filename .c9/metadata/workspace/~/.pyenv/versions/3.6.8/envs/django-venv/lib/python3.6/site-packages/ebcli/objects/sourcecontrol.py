{"changed":true,"filter":false,"title":"sourcecontrol.py","tooltip":"~/.pyenv/versions/3.6.8/envs/django-venv/lib/python3.6/site-packages/ebcli/objects/sourcecontrol.py","ace":{},"value":"# Copyright 2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"). You\n# may not use this file except in compliance with the License. A copy of\n# the License is located at\n#\n# http://aws.amazon.com/apache2.0/\n#\n# or in the \"license\" file accompanying this file. This file is\n# distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n# ANY KIND, either express or implied. See the License for the specific\n# language governing permissions and limitations under the License.\n\nfrom __future__ import print_function\nimport datetime\nimport fileinput\nimport os\nimport re\nimport subprocess\nimport sys\n\nfrom cement.utils.misc import minimal_logger\nfrom cement.utils.shell import exec_cmd\n\nfrom ebcli.lib import utils\nfrom ebcli.core import fileoperations, io\nfrom ebcli.objects.exceptions import (\n    CommandError,\n    NotInitializedError,\n    NoSourceControlError\n)\nfrom ebcli.resources.strings import git_ignore, strings\n\nLOG = minimal_logger(__name__)\n\n\nclass SourceControl(object):\n    name = 'base'\n\n    def __init__(self):\n        self.name = ''\n\n    def get_name(self):\n        return None\n\n    def get_current_branch(self):\n        pass\n\n    def do_zip(self, location, staged=False):\n        pass\n\n    def set_up_ignore_file(self):\n        pass\n\n    def get_version_label(self):\n        pass\n\n    def untracked_changes_exist(self):\n        pass\n\n    @staticmethod\n    def get_source_control():\n        try:\n            git_installed = fileoperations.get_config_setting('global', 'sc')\n        except NotInitializedError:\n            git_installed = False\n\n        if not git_installed:\n            if Git().is_setup():\n                return Git()\n            else:\n                return NoSC()\n\n        return Git()\n\n\nclass NoSC(SourceControl):\n    \"\"\"\n        No source control installed\n    \"\"\"\n    DEFAULT_MESSAGE = 'EB-CLI deploy'\n\n    def get_name(self):\n        return None\n\n    def get_version_label(self):\n        suffix = datetime.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n        return 'app-' + suffix\n\n    def get_current_branch(self):\n        return 'default'\n\n    def do_zip(self, location, staged=False):\n        io.log_info('Creating zip using systems zip')\n        fileoperations.zip_up_project(location)\n\n    def get_message(self):\n        return NoSC.DEFAULT_MESSAGE\n\n    def is_setup(self):\n        pass\n\n    def set_up_ignore_file(self):\n        Git().set_up_ignore_file()\n\n    def clean_up_ignore_file(self):\n        pass\n\n    def untracked_changes_exist(self):\n        return False\n\n\nclass Git(SourceControl):\n    \"\"\"\n    The user has git installed\n    \"\"\"\n    codecommit_remote_name = 'codecommit-origin'\n\n    def get_name(self):\n        return 'git'\n\n    def _handle_exitcode(self, exitcode, stderr):\n        if exitcode == 0:\n            return\n        if exitcode == 127:\n            # 127 = git not installed\n            raise NoSourceControlError\n        if exitcode == 128:\n            # 128 = No HEAD\n            if \"HEAD\" in stderr:\n                LOG.debug(\n                    'An error occurred while handling git command.\\nError code: '\n                    + str(exitcode)\n                    + ' Error: '\n                    + stderr\n                )\n                raise CommandError(\n                    'git could not find the HEAD; '\n                    'most likely because there are no commits present'\n                )\n\n        raise CommandError('An error occurred while handling git command.'\n                           '\\nError code: ' + str(exitcode) + ' Error: ' +\n                           stderr)\n\n    def get_version_label(self):\n        io.log_info('Getting version label from git with git-describe')\n        stdout, stderr, exitcode = \\\n            self._run_cmd(['git', 'describe', '--always', '--abbrev=4'])\n\n        version_label = 'app-{}-{:%y%m%d_%H%M%S}'.format(stdout, datetime.datetime.now())\n        return version_label.replace('.', '_')\n\n    def untracked_changes_exist(self):\n        try:\n            result = subprocess.check_output(['git', 'diff', '--numstat'])\n\n            if isinstance(result, bytes):\n                result = result.decode()\n\n            LOG.debug('Result of `git diff --numstat`: ' + result)\n        except subprocess.CalledProcessError as e:\n            LOG.debug('`git diff --numstat` resulted in an error: ' + str(e))\n\n    def get_current_repository(self):\n        current_branch = self.get_current_branch()\n        get_remote_name_command = ['git', 'config', '--get', 'branch.{0}.remote'.format(current_branch)]\n        LOG.debug(\n            'Getting current repository name based on the current branch name:'\n            '{0}'.format(' '.join(get_remote_name_command))\n        )\n\n        stdout, stderr, exitcode = self._run_cmd(\n            get_remote_name_command,\n            handle_exitcode=False\n        )\n\n        current_remote = stdout\n        if exitcode != 0:\n            LOG.debug(\"No remote found for the current working directory.\")\n            current_remote = \"origin\"\n\n        LOG.debug('Found remote: {}'.format(current_remote))\n        return current_remote\n\n    def get_current_branch(self):\n        revparse_command = ['git', 'rev-parse', '--abbrev-ref', 'HEAD']\n        LOG.debug('Getting current branch name by performing `{0}`'.format(' '.join(revparse_command)))\n\n        stdout, stderr, exitcode = self._run_cmd(revparse_command, handle_exitcode=False)\n\n        if stdout.strip() == 'HEAD':\n            io.log_warning('Git is in a detached head state. Using branch \"default\".')\n            return 'default'\n        else:\n            self._handle_exitcode(exitcode, stderr)\n\n        LOG.debug(stdout)\n\n        return stdout\n\n    def get_current_commit(self):\n        latest_commit_command = ['git', 'rev-parse', '--verify', 'HEAD']\n        LOG.debug('Getting current commit by performing `{0}`'.format(' '.join(latest_commit_command)))\n\n        stdout, stderr, exitcode = self._run_cmd(\n            latest_commit_command,\n            handle_exitcode=False\n        )\n        if exitcode != 0:\n            LOG.debug('No current commit found')\n            return\n        else:\n            self._handle_exitcode(exitcode, stderr)\n\n        LOG.debug(stdout)\n        return stdout\n\n    def do_zip_submodule(self, main_location, sub_location, staged=False, submodule_dir=None):\n        if staged:\n            commit_id, stderr, exitcode = self._run_cmd(['git', 'write-tree'])\n\n        else:\n            commit_id = 'HEAD'\n\n        io.log_info('creating zip using git submodule archive {0}'.format(commit_id))\n\n        # individually zip submodules if there are any\n        stdout, stderr, exitcode = self._run_cmd(['git', 'archive', '-v', '--format=zip',\n                                                  '--prefix', os.path.join(submodule_dir, ''),\n                                                  '-o', sub_location, commit_id])\n        io.log_info('git archive output: {0}'.format(stderr))\n\n        fileoperations.zip_append_archive(main_location, sub_location)\n        fileoperations.delete_file(sub_location)\n\n    def do_zip(self, location, staged=False):\n        cwd = os.getcwd()\n        try:\n            fileoperations.ProjectRoot.traverse()\n\n            if staged:\n                commit_id, stderr, exitcode = self._run_cmd(['git', 'write-tree'])\n            else:\n                commit_id = 'HEAD'\n\n            io.log_info('creating zip using git archive {0}'.format(commit_id))\n            stdout, stderr, exitcode = self._run_cmd(\n                ['git', 'archive', '-v', '--format=zip',\n                 '-o', location, commit_id])\n            io.log_info('git archive output: {0}'.format(stderr))\n\n            project_root = os.getcwd()\n\n            must_zip_submodules = fileoperations.get_config_setting('global', 'include_git_submodules')\n\n            if must_zip_submodules:\n                stdout, stderr, exitcode = self._run_cmd(['git', 'submodule', 'foreach', '--recursive'])\n\n                for index, line in enumerate(stdout.splitlines()):\n                    submodule_dir = line.split(' ')[1].strip('\\'')\n                    os.chdir(os.path.join(project_root, submodule_dir))\n                    self.do_zip_submodule(\n                        location,\n                        \"{0}_{1}\".format(\n                            location,\n                            str(index)\n                        ),\n                        staged=staged,\n                        submodule_dir=submodule_dir\n                    )\n\n        finally:\n            os.chdir(cwd)\n\n    def get_message(self):\n        stdout, stderr, exitcode = self._run_cmd(\n            ['git', 'log', '--oneline', '-1'])\n        return stdout.split(' ', 1)[1]\n\n    def is_setup(self):\n        if fileoperations.is_git_directory_present():\n            if not fileoperations.program_is_installed('git'):\n                raise CommandError(strings['sc.gitnotinstalled'])\n            else:\n                return True\n        return False\n\n    def set_up_ignore_file(self):\n        if not os.path.exists('.gitignore'):\n            open('.gitignore', 'w')\n        else:\n            with open('.gitignore', 'r', encoding='utf-8') as f:\n                for line in f:\n                    if line.strip() == git_ignore[0]:\n                        return\n\n        with open('.gitignore', 'a') as f:\n            f.write('\\n')\n            for line in git_ignore:\n                f.write('{}\\n'.format(line))\n\n    def clean_up_ignore_file(self):\n        cwd = os.getcwd()\n        try:\n            fileoperations.ProjectRoot.traverse()\n\n            in_section = False\n            for line in fileinput.input('.gitignore', inplace=True):\n                if line.startswith(git_ignore[0]):\n                    in_section = True\n                if not line.strip():\n                    in_section = False\n\n                if not in_section:\n                    print(line, end='')\n\n        finally:\n            os.chdir(cwd)\n\n    def push_codecommit_code(self):\n        io.log_info('Pushing local code to codecommit with git-push')\n\n        stdout, stderr, exitcode = self._run_cmd(\n            [\n                'git', 'push',\n                self.get_current_repository(),\n                self.get_current_branch()\n            ]\n        )\n\n        if exitcode != 0:\n            io.log_warning('Git is not able to push code: {0}'.format(exitcode))\n            io.log_warning(stderr)\n        else:\n            LOG.debug('git push result: {0}'.format(stdout))\n            self._handle_exitcode(exitcode, stderr)\n\n    def setup_codecommit_remote_repo(self, remote_url):\n        self.verify_url_is_a_codecommit_url(remote_url)\n        remote_add_command = ['git', 'remote', 'add', self.codecommit_remote_name, remote_url]\n        LOG.debug('Adding remote: {0}'.format(' '.join(remote_add_command)))\n\n        stdout, stderr, exitcode = self._run_cmd(remote_add_command, handle_exitcode=False)\n\n        if exitcode != 0:\n            if exitcode == 128:\n                remote_set_url_command = [\n                    'git', 'remote', 'set-url',\n                    self.codecommit_remote_name,\n                    remote_url\n                ]\n                LOG.debug(\n                    'Remote already exists, performing: {0}'.format(\n                        ' '.join(remote_set_url_command)\n                    )\n                )\n                self._run_cmd(remote_set_url_command)\n\n                remote_set_url_with_push_command = [\n                    'git',\n                    'remote',\n                    'set-url',\n                    '--push',\n                    self.codecommit_remote_name,\n                    remote_url\n                ]\n                LOG.debug(\n                    '                {0}'.format(\n                        ' '.join(remote_set_url_with_push_command)\n                    )\n                )\n                self._run_cmd(remote_set_url_with_push_command)\n            else:\n                LOG.debug(\"Error setting up git config for CodeCommit: {0}\".format(stderr))\n                return\n        else:\n            remote_set_url_with_add_push_command = [\n                'git', 'remote', 'set-url',\n                '--add',\n                '--push',\n                self.codecommit_remote_name,\n                remote_url\n            ]\n            LOG.debug(\n                'Setting remote URL and pushing to it: {0}'.format(\n                    ' '.join(remote_set_url_with_add_push_command)\n                )\n            )\n            self._run_cmd(remote_set_url_with_add_push_command)\n            self._handle_exitcode(exitcode, stderr)\n\n        LOG.debug('git remote result: ' + stdout)\n\n    def setup_new_codecommit_branch(self, branch_name):\n        LOG.debug(\"Setting up CodeCommit branch\")\n\n        self.fetch_remote_branches(self.codecommit_remote_name)\n\n        self.checkout_branch(branch_name, create_branch=True)\n\n        stdout, stderr, exitcode = self._run_cmd(\n            ['git', 'push', '-u', self.codecommit_remote_name, branch_name],\n            handle_exitcode=False\n        )\n\n        if exitcode == 1:\n            io.log_warning('Git is not able to push code: {0}'.format(exitcode))\n            io.log_warning(stderr)\n\n        if stderr:\n            LOG.debug('git push error: ' + stderr)\n\n        LOG.debug('git push result: ' + stdout)\n\n        self.fetch_remote_branches(self.codecommit_remote_name)\n\n        stdout, stderr, exitcode = self._run_cmd(\n            [\n                'git',\n                'branch',\n                '--set-upstream-to',\n                '{0}/{1}'.format(self.codecommit_remote_name, branch_name)\n            ],\n            handle_exitcode=False\n        )\n\n        if stderr:\n            LOG.debug('git branch --set-upstream-to error: ' + stderr)\n\n        LOG.debug('git branch result: ' + stdout)\n\n    def setup_existing_codecommit_branch(self, branch_name, remote_url=None):\n        self.fetch_remote_branches(self.codecommit_remote_name, remote_url)\n\n        self.checkout_branch(branch_name, create_branch=True)\n\n        stdout, stderr, exitcode = self._run_cmd(\n            [\n                'git', 'branch', '--set-upstream-to', \"{0}/{1}\".format(\n                    self.codecommit_remote_name,\n                    branch_name\n                )\n            ],\n            handle_exitcode=False\n        )\n\n        if exitcode != 0:\n            LOG.debug('git branch --set-upstream-to error: ' + stderr)\n            return False\n\n        LOG.debug('git branch result: ' + stdout)\n\n        return True\n\n    def checkout_branch(self, branch_name, create_branch=False):\n        stdout, stderr, exitcode = self._run_cmd(['git', 'checkout', branch_name], handle_exitcode=False)\n\n        if exitcode != 0:\n            LOG.debug('Git is not able to checkout code: {0}'.format(exitcode))\n            LOG.debug(stderr)\n            if exitcode == 1:\n                if create_branch:\n                    LOG.debug(\n                        \"Could not checkout branch '{0}', creating the branch \"\n                        \"locally with current HEAD\".format(branch_name)\n                    )\n                    self._run_cmd(['git', 'checkout', '-b', branch_name])\n                else:\n                    return False\n        return True\n\n    def get_list_of_staged_files(self):\n        stdout, stderr, exitcode = self._run_cmd(['git', 'diff', '--name-only', '--cached'])\n        LOG.debug('git diff result: {0}'.format(stdout))\n        return stdout\n\n    def create_initial_commit(self):\n        with open('README', 'w') as readme:\n            readme.write('')\n        self._run_cmd(['git', 'add', 'README'])\n        stdout, stderr, exitcode = self._run_cmd(\n            ['git', 'commit', '--allow-empty', '-m', 'EB CLI initial commit'],\n            handle_exitcode=False\n        )\n\n        if exitcode != 0:\n            LOG.debug('git was not able to initialize an empty commit: {0}'.format(stderr))\n\n        LOG.debug('git commit result: {0}'.format(stdout))\n        return stdout\n\n    def fetch_remote_branches(self, remote_name, remote_url=None):\n        if not remote_url:\n            fetch_command = [\n                'git',\n                'fetch',\n                self.get_current_repository(),\n                '+refs/heads/*:refs/remotes/{0}/*'.format(remote_name)\n            ]\n            LOG.debug('Fetching remote branches using remote name: {0}'.format(' '.join(fetch_command)))\n        else:\n            self.verify_url_is_a_codecommit_url(remote_url)\n\n            fetch_command = [\n                'git',\n                'fetch',\n                remote_url\n            ]\n            LOG.debug('Fetching remote branches using remote URL: {0}'.format(' '.join(fetch_command)))\n\n        stdout, stderr, exitcode = self._run_cmd(fetch_command, handle_exitcode=False)\n\n        if stderr:\n            LOG.debug('git fetch error: ' + stderr)\n\n        LOG.debug('git fetch result: {0}'.format(stdout))\n\n    def setup_codecommit_cred_config(self):\n        LOG.debug('Setup git config settings for code commit credentials')\n        self._run_cmd(\n            ['git', 'config', '--local', '--replace-all', 'credential.UseHttpPath', 'true'])\n\n        self._run_cmd(\n            ['git', 'config', '--local', '--replace-all', 'credential.helper', credential_helper_command()])\n\n    def _run_cmd(self, cmd, handle_exitcode=True):\n        stdout, stderr, exitcode = exec_cmd(cmd)\n\n        stdout = utils.decode_bytes(stdout).strip()\n        stderr = utils.decode_bytes(stderr).strip()\n\n        if handle_exitcode:\n            self._handle_exitcode(exitcode, stderr)\n        return stdout, stderr, exitcode\n\n    def verify_url_is_a_codecommit_url(self, remote_url):\n        codecommit_url_regex = re.compile(r'.*git-codecommit\\..*\\.amazonaws.com.*')\n\n        if not codecommit_url_regex.search(remote_url):\n            # Prevent communications with non-CodeCommit repositories because of unknown security implications\n            # Integration with non-CodeCommit repositories is not something Beanstalk presently supports\n            raise NoSourceControlError('Could not connect to repository located at {}'.format(remote_url))\n\n\ndef credential_helper_command():\n    return '!aws codecommit credential-helper $@'\n","undoManager":{"mark":-1,"position":-1,"stack":[]},"timestamp":1557988694458}